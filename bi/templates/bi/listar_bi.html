<!-- bi/templates/bi/listar_bi.html -->
{% extends 'base.html' %}
{% load static %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/listar_bi.css' %}">
<style>
  /* Pill de refresh em andamento (mesmo visual do visualizar_bi) */
  .refresh-pill{
    display:inline-flex; align-items:center; gap:.45rem;
    padding:.25rem .6rem; border:1px solid #e5e7eb; border-radius:999px;
    background:rgba(245,158,11,.10); user-select:none;
    margin-left:.5rem; font-size:.95rem;
  }
  .refresh-pill .dot{
    width:8px; height:8px; border-radius:999px; background:#f59e0b;
    box-shadow:0 0 0 0 rgba(245,158,11,.6); animation: pillping 1.2s infinite;
  }
  @keyframes pillping { to { box-shadow:0 0 0 10px rgba(245,158,11,0); } }
</style>
{% endblock %}

{% block content %}
<div class="container">
  <h1>Lista de BIs</h1>

  <!-- Busca -->
  <div class="filters-container">
    <div class="search-container">
      <input type="text" id="searchInput" class="search-input" placeholder="Buscar BIs...">
    </div>
  </div>

  <!-- Lista -->
  <div class="bi-list" id="biList">
    {% for bi in bi_reports %}
      <div class="bi-container">
        <div class="bi-item"
             data-report-id="{{ bi.report_id }}"
             data-group-id="{{ bi.group_id }}">

          <!-- Ícone -->
          <div class="bi-status">
            <img src="{% static 'images/bi-icon.png' %}" alt="BI" class="status-icon">
          </div>

          <!-- Informações -->
          <div class="bi-info">
            <div class="bi-grid">
              <div><strong>Título:</strong> {{ bi.title }}</div>

              <!-- Atualização + Pill -->
              <div>
                <div class="last-upd" id="lastUpd-{{ bi.pk }}"
                     data-last-epoch=""
                     data-last-iso=""
                     data-next-epoch=""
                     data-next-iso=""
                     title="Última atualização do dataset no Power BI">
                  <strong>Atualização:</strong>
                  <span class="lastUpdText">Carregando…</span>

                  <!-- Pill de status (inicialmente escondida) -->
                  <span class="refresh-pill" data-role="row-refresh-pill" style="display:none"
                        title="Há uma atualização em andamento">
                    <span class="dot" aria-hidden="true"></span>
                    <span class="pill-text">Atualização em andamento…</span>
                  </span>
                </div>
              </div>

              <div></div>
            </div>
          </div>

          <!-- Ações -->
          <div class="bi-actions">
            {% if perms.bi.refresh_bi %}
            <button type="button" class="action-icon refresh-btn"
                    title="Atualizar dados do Power BI"
                    aria-live="polite" aria-busy="false">
              <img src="{% static 'images/refresh-icon.png' %}" alt="Atualizar">
              <span class="tooltip-text">Atualizar</span>
            </button>
            {% endif %}

            <a href="{% url 'bi:bi_report_detail' bi.pk %}"
               class="action-icon {% if not request.user in bi.allowed_users.all %}disabled{% endif %}">
              <img src="{% static 'images/view-icon.png' %}" alt="Visualizar" class="view-icon">
              <span class="tooltip-text">Visualizar</span>
            </a>

            {% if perms.bi.view_access %}
            <a href="{% url 'bi:visualizar_acessos_bi' bi.pk %}" class="action-icon">
              <img src="{% static 'images/acessou.png' %}" alt="Acessos" class="access-icon">
              <span class="tooltip-text">Acessos</span>
            </a>
            {% endif %}

            {% if perms.bi.edit_bi %}
            <a href="{% url 'bi:edit_bi_report' bi.pk %}" class="action-icon">
              <img src="{% static 'images/edit-icon.png' %}" alt="Editar" class="edit-icon">
              <span class="tooltip-text">Editar</span>
            </a>
            {% endif %}
          </div>
        </div>
      </div>
    {% empty %}
      <p class="no-bis-message">Nenhum BI encontrado.</p>
    {% endfor %}
  </div>
</div>

<!-- Scripts -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // ====== Busca ======
  const searchInput  = document.getElementById('searchInput');
  const biContainers = document.querySelectorAll('.bi-container');

  function filterBIs() {
    const term = (searchInput.value || '').toLowerCase();
    biContainers.forEach(container => {
      const title = container.querySelector('.bi-grid div:nth-child(1)')?.innerText?.toLowerCase() || '';
      container.style.display = title.includes(term) ? '' : 'none';
    });

    const visible = Array.from(biContainers).filter(b => b.style.display !== 'none').length;
    let msg = document.getElementById('noResultsMessage');
    if (!visible) {
      if (!msg) {
        msg = document.createElement('div');
        msg.id = 'noResultsMessage';
        msg.innerText = 'Nenhum BI encontrado.';
        msg.style.textAlign = 'center';
        msg.style.marginTop = '20px';
        msg.style.color = '#f00';
        document.getElementById('biList').appendChild(msg);
      }
      msg.style.display = 'block';
    } else if (msg) {
      msg.style.display = 'none';
    }
  }
  searchInput.addEventListener('keyup', filterBIs);

  // ====== Utils ======
  const TZ_DEFAULT = 'America/Sao_Paulo';

  function fmtBr(dt, tz = TZ_DEFAULT){
    try {
      return new Intl.DateTimeFormat('pt-BR', { dateStyle:'short', timeStyle:'short', timeZone: tz }).format(dt);
    } catch { return dt.toLocaleString('pt-BR'); }
  }
  function timeAgo(fromDate){
    const s = Math.max(0, Math.floor((Date.now()-fromDate.getTime())/1000));
    if (s < 60) return `há ${s}s`;
    const m = Math.floor(s/60); if (m < 60) return `há ${m} min`;
    const h = Math.floor(m/60); if (h < 24) return `há ${h} h`;
    const d = Math.floor(h/24); return `há ${d} d`;
  }
  function getDateFromAttrs(wrap, prefix){
    const raw = wrap.getAttribute(`data-${prefix}-epoch`);
    const hasEpoch = raw !== null && raw !== '' && !Number.isNaN(Number(raw));
    const epoch = hasEpoch ? Number(raw) : 0;
    if (epoch > 0) return new Date(epoch * 1000);
    const iso = wrap.getAttribute(`data-${prefix}-iso`) || '';
    const d = iso ? new Date(iso) : null;
    return d && !isNaN(d.getTime()) ? d : null;
  }
  function updateBadge(el, tz = TZ_DEFAULT){
    if (!el) return;
    const label = el.querySelector('.lastUpdText');
    const dt = getDateFromAttrs(el,'last');
    const ndt= getDateFromAttrs(el,'next');

    el.classList.remove('ok','warn','stale','unknown');
    if (!dt){
      el.classList.add('unknown');
      if (label) label.textContent = '—';
      el.title = 'Sem informação de atualização do dataset';
      return;
    }
    const ageH = (Date.now() - dt.getTime())/36e5;
    if (ageH <= 3) el.classList.add('ok');
    else if (ageH <= 24) el.classList.add('warn');
    else el.classList.add('stale');

    if (label) label.textContent = `${fmtBr(dt, tz)} (${timeAgo(dt)})`;
    el.title = ndt
      ? `Última: ${fmtBr(dt, tz)}\nPróxima prevista: ${fmtBr(ndt, tz)}`
      : `Última: ${fmtBr(dt, tz)}`;
  }
  function getCookie(name){
    const v = `; ${document.cookie}`;
    const parts = v.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return '';
  }
  function _lc(v){ return (v==null ? '' : String(v)).toLowerCase().trim(); }

  // --- Sufixo “via ...” (api | PowerBI Web) ---
  function inferChannelTag(obj, rawType){
    const bag = [
      rawType, obj.refresh_type, obj.type, obj.refreshType,
      obj.trigger_source, obj.triggerSource,
      obj.initiated_by, obj.initiatedBy,
      obj.requested_by, obj.requestedBy,
      obj.source, obj.via, obj.method, obj.origin, obj.entityType
    ].map(x => String(x || '')).join('|').toLowerCase();

    if (/(api|enhancedapi|xmla|rest|sdk|powershell)/.test(bag)) return 'via api';
    if (/(scheduled|agendado)/.test(bag)) return 'via PowerBI Web';
    if (/(manual|on[-\s]?demand|ui|web)/.test(bag)) return 'via PowerBI Web';
    return 'via PowerBI Web';
  }

  function normalizeOneRefresh(obj){
    const rawStatus = _lc(obj.status ?? obj.state ?? obj.refresh_status ?? obj.stage);
    const rawType   = _lc(obj.refresh_type ?? obj.type ?? obj.refreshType);
    const inProgFlags = new Set(['inprogress','running','notstarted','pending','queued']);

    const bools = (obj.in_progress ?? obj.inProgress ?? obj.is_running ?? obj.running ?? false) ? true : false;
    const hasStart = Number.isFinite(obj.start_epoch) || obj.startTime || obj.startDateTime;
    const hasEnd   = Number.isFinite(obj.end_epoch)   || obj.endTime   || obj.endDateTime;

    const inProgress = bools || inProgFlags.has(rawStatus) || (hasStart && !hasEnd);
    const failed = new Set(['failed','cancelled','canceled','disabled','error']).has(rawStatus);

    const origin = inferChannelTag(obj, rawType);

    const errMsg = obj.error_message ?? obj.errorMessage ?? obj.message ?? '';
    const errCode= obj.error_code ?? obj.errorCode ?? '';

    return {
      inProgress, failed, origin, rawStatus, rawType,
      errMsg: (typeof errMsg === 'string' ? errMsg : ''),
      errCode: (typeof errCode === 'string' ? errCode : ''),
      start_epoch: obj.start_epoch, end_epoch: obj.end_epoch
    };
  }
  function pickStatusFromResponse(resp){
    const list = Array.isArray(resp)            ? resp
               : Array.isArray(resp?.items)     ? resp.items
               : Array.isArray(resp?.refreshes) ? resp.refreshes
               : resp?.item ? [resp.item]
               : [resp];

    const normalized = list.map(normalizeOneRefresh);

    const anyFailed  = normalized.find(x => x.failed);
    if (anyFailed) return { inProgress:false, failed:true, origin:anyFailed.origin, error:anyFailed.errMsg, code:anyFailed.errCode, debug:normalized };

    const anyRunning = normalized.find(x => x.inProgress);
    if (anyRunning) return { inProgress:true, failed:false, origin:anyRunning.origin, debug:normalized };

    return { inProgress:false, failed:false, origin:'via PowerBI Web', debug:normalized };
  }

  // ====== Sticky origin helpers ======
  const MAX_STICKY_MS = 20 * 60 * 1000; // segura no máx. 20 min se backend não reportar DF
  function setRowStickyOrigin(row, origin, beforeEpoch){
    row.__originSticky = origin;            // 'via api' ou 'via PowerBI Web'
    row.__stickyStartAt = Date.now();
    row.__beforeEpoch = Number(beforeEpoch || 0);
  }
  function clearRowSticky(row){
    row.__originSticky = null;
    row.__stickyStartAt = null;
    row.__beforeEpoch = null;
  }
  function getRowOrigin(row, fallback){
    return row.__originSticky || fallback || 'via PowerBI Web';
  }
  function shouldHoldSticky(row){
    // mantém a pill se: (a) ainda dentro do tempo máx e (b) o timestamp do dataset não virou
    const badge = row.querySelector('.last-upd');
    const nowEpoch = Number(badge?.getAttribute('data-last-epoch') || 0);
    const notTurned = !(nowEpoch && row.__beforeEpoch && nowEpoch > row.__beforeEpoch);
    const withinTime = (Date.now() - (row.__stickyStartAt || 0)) < MAX_STICKY_MS;
    return Boolean(row.__originSticky && withinTime && notTurned);
  }

  // ====== Botão Atualizar – animação/disable conforme origem ======
  function setBtnLoading(btn, isLoading){
    btn?.classList.toggle('loading', !!isLoading);
    if (btn){
      btn.disabled = !!isLoading;
      btn.setAttribute('aria-busy', isLoading ? 'true' : 'false');
    }
  }
  function updateRefreshBtnByStatus(row, { inProgress, origin }){
    const btn = row.querySelector('.refresh-btn');
    if (!btn) return;
    const isApi = String(origin || '').toLowerCase().includes('api');
    if (inProgress){
      if (isApi){
        // API -> anima e desabilita
        setBtnLoading(btn, true);
      } else {
        // Web -> somente desabilita (sem classe .loading)
        btn.classList.remove('loading');
        btn.disabled = true;
        btn.setAttribute('aria-busy','true');
      }
    } else {
      // terminou -> liberar
      setBtnLoading(btn, false);
    }
  }

  // ====== API helpers (por linha) ======
  async function getRowRefreshStatus(row, afterEpoch){
    const reportId = row.getAttribute('data-report-id');
    const groupId  = row.getAttribute('data-group-id');
    if (!reportId || !groupId) return { inProgress:false, failed:false, origin:'via PowerBI Web' };

    const r = await fetch("{% url 'bi:get_refresh_status' %}", {
      method: 'POST',
      headers: { 'Content-Type':'application/json', 'X-CSRFToken': getCookie('csrftoken') },
      body: JSON.stringify({
        report_id: reportId,
        group_id: groupId,
        after_epoch: afterEpoch || null,
        include_dataflows: true
      }),
      cache: 'no-store', credentials: 'same-origin'
    });
    const txt = await r.text();
    if (!r.ok) throw new Error(`get_refresh_status HTTP ${r.status}`);
    const data = JSON.parse(txt || '{}');
    return pickStatusFromResponse(data);
  }

  // ====== Badges via API ======
  async function fetchAndPaintBadge(row){
    const reportId = row.getAttribute('data-report-id');
    const groupId  = row.getAttribute('data-group-id');
    const badge    = row.querySelector('.last-upd');
    if (!reportId || !groupId || !badge) return;

    try{
      const r = await fetch("{% url 'bi:get_last_update_rt' %}", {
        method: 'POST',
        headers: {
          'Content-Type':'application/json',
          'Accept':'application/json',
          'X-CSRFToken': getCookie('csrftoken'),
        },
        body: JSON.stringify({ report_id: reportId, group_id: groupId }),
        cache: 'no-store',
        credentials: 'same-origin',
      });
      const txt = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status}`);

      const data = JSON.parse(txt || '{}');
      if (data && data.ok){
        badge.setAttribute('data-last-epoch', data.last_updated_epoch ?? '');
        badge.setAttribute('data-last-iso',   data.last_updated_iso   ?? '');
        badge.setAttribute('data-next-epoch', data.next_update_epoch ?? '');
        badge.setAttribute('data-next-iso',   data.next_update_iso    ?? '');
        updateBadge(badge, data.tz || TZ_DEFAULT);
      } else {
        updateBadge(badge, TZ_DEFAULT);
      }
    }catch(err){
      console.warn('get_last_update_rt fail', err);
      updateBadge(badge, TZ_DEFAULT);
    }
  }

  // ====== Pill helpers (por linha) ======
  function setRowRefreshPill(row, on, text){
    const pill = row.querySelector('[data-role="row-refresh-pill"]');
    const pillText = pill?.querySelector('.pill-text');
    if (!pill) return;
    pill.style.display = on ? 'inline-flex' : 'none';
    if (on && text && pillText) pillText.textContent = text;
  }
  function stopRowRefreshPolling(row){
    if (row._pollTimer){ clearInterval(row._pollTimer); row._pollTimer = null; }
    setRowRefreshPill(row, false);
    updateRefreshBtnByStatus(row, { inProgress:false, origin:'api' });
    clearRowSticky(row);
  }
  function startRowRefreshPolling(row, label='via PowerBI Web'){
    // já polling? só atualiza texto
    if (row._pollTimer){
      setRowRefreshPill(row, true, `Atualização em andamento… (${getRowOrigin(row, label)})`);
      updateRefreshBtnByStatus(row, { inProgress:true, origin:getRowOrigin(row, label) });
      return;
    }
    setRowRefreshPill(row, true, `Atualização em andamento… (${getRowOrigin(row, label)})`);
    updateRefreshBtnByStatus(row, { inProgress:true, origin:getRowOrigin(row, label) });

    const TICK_MS = 10_000;
    row._pollTimer = setInterval(async () => {
      try{
        const picked = await getRowRefreshStatus(row);
        if (picked.failed){
          stopRowRefreshPolling(row);
          alert(picked.error || 'Falha na atualização do dataset.');
          return;
        }
        if (picked.inProgress){
          setRowRefreshPill(row, true, `Atualização em andamento… (${getRowOrigin(row, picked.origin)})`);
          updateRefreshBtnByStatus(row, { inProgress:true, origin:getRowOrigin(row, picked.origin) });
        } else {
          // dataset não reporta progresso — segura a pill/botão se disparado pela tela e dataset ainda não virou
          if (shouldHoldSticky(row)){
            setRowRefreshPill(row, true, `Atualização em andamento… (${getRowOrigin(row)})`);
            updateRefreshBtnByStatus(row, { inProgress:true, origin:getRowOrigin(row) });
          } else {
            stopRowRefreshPolling(row);
            await fetchAndPaintBadge(row);
          }
        }
      }catch(e){
        if (shouldHoldSticky(row)){
          setRowRefreshPill(row, true, `Atualização em andamento… (${getRowOrigin(row)})`);
          updateRefreshBtnByStatus(row, { inProgress:true, origin:getRowOrigin(row) });
        } else {
          stopRowRefreshPolling(row);
        }
      }
    }, TICK_MS);
  }
  async function probeRowRefreshStart(row){
    try{
      const picked = await getRowRefreshStatus(row);
      if (picked.failed){
        stopRowRefreshPolling(row);
        return;
      }
      if (picked.inProgress){
        startRowRefreshPolling(row, picked.origin);
      } else {
        if (!shouldHoldSticky(row)) stopRowRefreshPolling(row);
      }
    }catch(e){
      // silencioso
    }
  }

  // limitador de concorrência p/ não martelar a API
  async function hydrateAllBadges(concurrency = 4){
    const rows = Array.from(document.querySelectorAll('.bi-item'));
    let i = 0;
    async function worker(){
      while(i < rows.length){
        const row = rows[i++];
        await fetchAndPaintBadge(row);
        await probeRowRefreshStart(row); // 👈 sonda status de refresh
      }
    }
    const n = Math.min(concurrency, rows.length || 1);
    await Promise.all(Array.from({length:n}, worker));
  }

  // primeira hidratação via API + refresh “há X” a cada 60s
  hydrateAllBadges();
  setInterval(() => {
    document.querySelectorAll('.last-upd').forEach(el => updateBadge(el));
  }, 60_000);
  // refresh dos badges + sonda de status a cada 25s/5min
  setInterval(() => {
    document.querySelectorAll('.bi-item').forEach(row => probeRowRefreshStart(row));
  }, 25_000);
  setInterval(() => hydrateAllBadges(), 5 * 60_000);

  // ====== Botão Atualizar (por BI) ======
  function getBadgeEpoch(el){
    const n = Number(el?.getAttribute('data-last-epoch') || 0);
    return Number.isFinite(n) ? n : 0;
  }

  async function refreshRow(row){
    const btn   = row.querySelector('.refresh-btn');
    const badge = row.querySelector('.last-upd');
    const reportId = row.getAttribute('data-report-id');
    const groupId  = row.getAttribute('data-group-id');
    if (!badge || !reportId || !groupId) return;

    try{
      const beforeEpoch = getBadgeEpoch(badge);

      // 🔒 sticky “via api” + anima botão agora
      setRowStickyOrigin(row, 'via api', beforeEpoch);
      updateRefreshBtnByStatus(row, { inProgress:true, origin:'via api' });
      startRowRefreshPolling(row, 'via api');

      // dispara refresh (dataset + dataflows em cascata)
      const res = await fetch("{% url 'bi:refresh_now' %}", {
        method: 'POST',
        headers: { 'Content-Type':'application/json', 'X-CSRFToken': getCookie('csrftoken') },
        body: JSON.stringify({
          report_id: reportId,
          group_id:  groupId,
          cascade: true,
          wait_for_dataflows: true,
          fail_on_dataflow_error: true,
          df_timeout_s: 3600,
          poll_every_s: 20,
          refresh_type: 'Full'
        }),
        cache: 'no-store', credentials: 'same-origin'
      });
      const txt = await res.text();
      if (res.status === 429){
        try { const j = JSON.parse(txt||'{}'); alert(`Uma atualização acabou de ser solicitada. Tente novamente em ~${j.retry_seconds || 60}s.`); }
        catch { alert('Aguarde um pouco antes de tentar novamente.'); }
        // não iniciou — desfaz UI
        stopRowRefreshPolling(row);
        return;
      }
      if (!res.ok){
        alert('Falha ao acionar a atualização do dataset.');
        stopRowRefreshPolling(row);
        return;
      }

      // polling leve da virada de timestamp
      const deadline = Date.now() + 15 * 60 * 1000;
      while (Date.now() < deadline){
        await new Promise(r => setTimeout(r, 10_000));
        await fetchAndPaintBadge(row);
        const nowEpoch = getBadgeEpoch(badge);
        if (nowEpoch && nowEpoch > beforeEpoch) break;
      }
    }catch(err){
      console.error('refreshRow fail', err);
      alert('Erro ao acionar atualização.');
      stopRowRefreshPolling(row);
    }finally{
      // Liberação final fica por conta do polling/sonda quando o processo terminar.
    }
  }

  document.querySelectorAll('.bi-item .refresh-btn').forEach(btn => {
    btn.addEventListener('click', (ev) => {
      const row = ev.currentTarget.closest('.bi-item');
      if (row) refreshRow(row);
    }, { passive: true });
  });
});
</script>
{% endblock %}
